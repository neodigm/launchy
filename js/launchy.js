var Launchy =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!************************!*\
  !*** ./src/launchy.js ***!
  \************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Launchy = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Launchy! ðŸš€ â€” An Accessible Modal Window\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Features include:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * - On launch, shift focus to the modal window container\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * - The modal window is described by the modal heading\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * - Trap keyboard focus within the modal when active/visible\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * - Close the window on `esc` key press\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * - Close the window on overlay `click`\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * - Set keyboard focus back to the launcher element on window close\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * - Transparent border for Windows High Contrast themes\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Check out the GitHub repo for more information: https://github.com/svinkle/launchy\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Scott Vinkle <svinkle@gmail.com>\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version 0.8.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license MIT\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n__webpack_require__(/*! wicg-inert */ 1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// HTML elements\nvar htmlElements = {\n    launchModal: 'a',\n    closeModal: 'a',\n    modalWindow: 'div',\n    modalContent: 'div',\n    modalOverlay: 'div',\n    modalTitle: 'h2'\n};\n\n// CSS classes\nvar classes = {\n    modalLaunchLink: 'launchy__launch-link',\n    modalCloseLink: 'launchy__close-link',\n    modalWindow: 'launchy__window',\n    modalContent: 'launchy__content',\n    modalOverlay: 'launchy__overlay',\n    modalTitle: 'launchy__title',\n    modalWindowIsVisible: 'launchy__window--is-visible',\n    modalOverlayIsVisible: 'launchy__overlay--is-visible'\n};\n\n// Data attributes\nvar data = {\n    launchyAriaHidden: 'data-launchy-aria-hidden',\n    launchyFocusable: 'data-launchy-focusable',\n    launchyTabIndex: 'data-launchy-tabindex',\n    launchyText: 'data-launchy-text',\n    launchyTitle: 'data-launchy-title',\n    launchyCustom: {\n        close: 'data-launchy-close',\n        refocus: 'data-launchy-refocus'\n    }\n};\n\n// Keys\nvar keysCodes = {\n    'Escape': 27\n};\n\n// Selectors\nvar selectors = {\n    launchyElements: '[data-launchy]',\n    launchyControl: 'launchy-control-',\n    launchyDialog: 'launchy-dialog-',\n    launchyCloseControl: 'launchy-close-control-',\n    modalOverlay: 'modal-overlay-',\n    modalTitle: 'modal-title-'\n};\n\n// Strings\nvar strings = {\n    modalClose: 'Close modal window!',\n    modalCloseHTML: '<span aria-hidden=\"true\">&times;</span>',\n    modalError: 'Launchy container must have a `data-launchy-text` attribute!',\n    modalErrorEmpty: 'Launchy container `data-launchy-text` attribute cannot be empty!',\n    modalWarning: 'Launchy container should have a `data-launchy-title` attribute, or be sure to supply your own heading! (Prefereably an `<h2>`.)',\n    refocusElemNotFound: 'Refocus element not found!'\n};\n\n// Unique identifier\nvar launchyId = 0;\n\nvar Launchy = function () {\n    function Launchy(params) {\n        _classCallCheck(this, Launchy);\n\n        // https://www.npmjs.com/package/focusable\n        this.focusable = __webpack_require__(/*! focusable */ 2);\n\n        // Unique identifier for each instance\n        this.launchyId = launchyId;\n\n        // Flags and other objects to be used later\n        this.hasTitle = params.title ? true : false;\n        this.modalIsVisible = false;\n        this.activeElement = null;\n        this.shiftKeyIsPressed = false;\n        this.allFocusable = null;\n        this.firstFocusable = null;\n        this.lastFocusable = null;\n        this.domFocusable = null;\n\n        // Setup all the things\n        this.prepareFocusable();\n        this.createElements(params);\n        this.insertElements(params);\n        this.setupEventListeners();\n\n        // Increment identifier\n        launchyId++;\n    }\n\n    /**\n     * Add a data attribute on all existing focusable elements. Used in\n     * `modalHide()` and `modalShow()` to make elements \"inert\" -- prevent\n     * screen readers from reaching these elements when using other means\n     * of navigation (arrow keys, for example.)\n     *\n     * @return {null}\n     */\n\n\n    _createClass(Launchy, [{\n        key: 'prepareFocusable',\n        value: function prepareFocusable() {\n\n            // Select all focusable elements in the DOM\n            this.domFocusable = document.querySelectorAll(this.focusable);\n\n            // For each focusable element in the DOM, set the data attribute\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = Array.from(this.domFocusable)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var domElement = _step.value;\n\n                    var addAttributes = false;\n\n                    // Check to see if the element already has `tabindex=\"-1\"`\n                    if (!domElement.hasAttribute('tabindex') || domElement.getAttribute('tabindex') !== '-1') {\n                        domElement.setAttribute(data.launchyTabIndex, true);\n                        addAttributes = true;\n                    }\n\n                    // Check to see if the element already has `aria-hidden=\"true\"`\n                    if (!domElement.hasAttribute('aria-hidden') || domElement.getAttribute('aria-hidden') !== 'true') {\n                        domElement.setAttribute(data.launchyAriaHidden, true);\n                        addAttributes = true;\n                    }\n\n                    // Only add this element to the set if the above conditions are met\n                    if (addAttributes) {\n                        domElement.setAttribute(data.launchyFocusable, true);\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Create all the required elements for Launchy to function.\n         *\n         * @param {Object} params Instance parameters\n         * @return {null}\n         */\n\n    }, {\n        key: 'createElements',\n        value: function createElements(params) {\n\n            // Launch control\n            this.launchControl = document.createElement(htmlElements.launchModal);\n            this.launchControl.id = '' + selectors.launchyControl + this.launchyId;\n            this.launchControl.href = '#' + selectors.launchyDialog + this.launchyId;\n            this.launchControl.classList.add(classes.modalLaunchLink);\n            this.launchControl.setAttribute('aria-haspopup', 'dialog');\n            this.launchControl.textContent = params.text;\n\n            // Close control\n            this.closeControl = document.createElement(htmlElements.closeModal);\n            this.closeControl.id = '' + selectors.launchyCloseControl + this.launchyId;\n            this.closeControl.href = '#' + selectors.launchyControl + this.launchyId;\n            this.closeControl.classList.add(classes.modalCloseLink);\n            this.closeControl.setAttribute('aria-label', strings.modalClose);\n            this.closeControl.innerHTML = strings.modalCloseHTML;\n\n            // Modal window\n            this.modalWindow = document.createElement(htmlElements.modalWindow);\n            this.modalWindow.id = '' + selectors.launchyDialog + this.launchyId;\n            this.modalWindow.classList.add(classes.modalWindow);\n            this.modalWindow.setAttribute('tabindex', -1);\n            this.modalWindow.setAttribute('role', 'dialog');\n            this.modalWindow.setAttribute('aria-modal', true);\n\n            if (this.hasTitle) {\n                this.modalWindow.setAttribute('aria-labelledby', '' + selectors.modalTitle + this.launchyId);\n            }\n\n            // Modal overlay\n            this.modalOverlay = document.createElement(htmlElements.modalOverlay);\n            this.modalOverlay.id = '' + selectors.modalOverlay + this.launchyId;\n            this.modalOverlay.classList.add(classes.modalOverlay);\n            this.modalOverlay.setAttribute('tabindex', 0);\n\n            // Modal content\n            this.modalContent = document.createElement(htmlElements.modalContent);\n            this.modalContent.classList.add(classes.modalContent);\n\n            // Modal title\n            if (this.hasTitle) {\n                this.modalTitle = document.createElement(htmlElements.modalTitle);\n                this.modalTitle.id = '' + selectors.modalTitle + this.launchyId;\n                this.modalTitle.classList.add(classes.modalTitle);\n                this.modalTitle.textContent = params.title;\n            }\n        }\n\n        /**\n         * Insert Launchy elements into the DOM.\n         *\n         * @param {Object} params instance parameters\n         * @return {null}\n         */\n\n    }, {\n        key: 'insertElements',\n        value: function insertElements(params) {\n\n            // Select all focusable elements in the modal content\n            var domFocusable = params.target.querySelectorAll(this.focusable);\n\n            // Launch control\n            params.target.parentNode.insertBefore(this.launchControl, params.target);\n\n            // Modal window\n            params.target.parentNode.insertBefore(this.modalWindow, params.target);\n\n            // Modal content container\n            this.modalWindow.appendChild(this.modalContent);\n\n            // Close control\n            this.modalContent.appendChild(this.closeControl);\n\n            // Modal title\n            if (this.hasTitle) {\n                this.modalContent.appendChild(this.modalTitle);\n            }\n\n            // Move the content within the modal container\n            this.modalContent.appendChild(params.target);\n\n            // Remove `data-launchy-focusable` from any elements within the\n            // modal content -- we don't want to make these inert\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = Array.from(domFocusable)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var domElement = _step2.value;\n\n                    domElement.removeAttribute(data.launchyAriaHidden);\n                    domElement.removeAttribute(data.launchyFocusable);\n                    domElement.removeAttribute(data.launchyTabIndex);\n                }\n\n                // Overlay\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            document.body.appendChild(this.modalOverlay);\n        }\n\n        /**\n         * Create event listeners for Launchy functionality.\n         *\n         * @return {null}\n         */\n\n    }, {\n        key: 'setupEventListeners',\n        value: function setupEventListeners() {\n\n            // Gather any custom close or refocus controls\n            var closeControls = this.modalContent.querySelectorAll('[' + data.launchyCustom.close + ']');\n            var refocusControls = this.modalContent.querySelectorAll('[' + data.launchyCustom.refocus + ']');\n\n            // Show the modal window on the launcher element `click` event\n            this.launchControl.addEventListener('click', this.showModal.bind(this), false);\n\n            // Hide the modal window on close button or overlay `click` event\n            this.closeControl.addEventListener('click', this.hideModal.bind(this), false);\n            this.modalOverlay.addEventListener('click', this.hideModal.bind(this), false);\n\n            // Trap the keyboard focus within modal window on the document\n            // `focus` event. Notice the use of the `useCapture` flag set to `true`; this\n            // indicates the event will be dispatched to the listener before any event\n            // target in the DOM:\n            // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n            document.addEventListener('focus', this.trapFocus.bind(this), true);\n\n            // Check for `esc` key press on the document `keydown` event\n            document.addEventListener('keydown', this.checkEsc.bind(this), false);\n\n            // Check for `shift` key press on the document `keydown` event\n            document.addEventListener('keydown', this.checkShift.bind(this), false);\n\n            // Add event listener for all custom close controls\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = Array.from(closeControls)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var closeControl = _step3.value;\n\n                    closeControl.addEventListener('click', this.hideModal.bind(this), false);\n                }\n\n                // Add event listener for all custom refocus controls\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n                for (var _iterator4 = Array.from(refocusControls)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                    var refocusControl = _step4.value;\n\n                    refocusControl.addEventListener('click', this.hideModalRefocus.bind(this), false);\n                }\n            } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                        _iterator4.return();\n                    }\n                } finally {\n                    if (_didIteratorError4) {\n                        throw _iteratorError4;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Show the modal window.\n         *\n         * @param {Object} e The event object\n         * @return {null}\n         */\n\n    }, {\n        key: 'showModal',\n        value: function showModal(e) {\n            e.preventDefault();\n\n            // Cache the last active element\n            this.activeElement = document.activeElement;\n\n            // Set visible flag as `true`\n            this.modalIsVisible = true;\n\n            // Set the focusable objects, first and last, within the modal window\n            this.allFocusable = this.modalWindow.querySelectorAll(this.focusable);\n            this.firstFocusable = this.allFocusable[0];\n            this.lastFocusable = this.allFocusable[this.allFocusable.length - 1];\n\n            // Add the `active` classes and set `aria-hidden` to `false`\n            this.modalWindow.classList.add(classes.modalWindowIsVisible);\n            this.modalOverlay.classList.add(classes.modalOverlayIsVisible);\n            this.modalWindow.setAttribute('aria-hidden', false);\n\n            // Set focusable elements as \"inert\"\n            this.inertElements(true);\n\n            // Shift keyboard focus to the modal window container\n            this.modalWindow.focus();\n        }\n    }, {\n        key: 'hideModal',\n\n\n        /**\n         * Hide the modal window.\n         *\n         * @param {Object} e The event object\n         * @return {null}\n         */\n        value: function hideModal(e) {\n            e.preventDefault();\n\n            // Set visible flag to `false`\n            this.modalIsVisible = false;\n\n            // Reset the focusable objects\n            this.allFocusable = null;\n            this.firstFocusable = null;\n            this.lastFocusable = null;\n\n            // Remove the `active` classes and set `aria-hidden` to `true`\n            this.modalWindow.classList.remove(classes.modalWindowIsVisible);\n            this.modalOverlay.classList.remove(classes.modalOverlayIsVisible);\n            this.modalWindow.setAttribute('aria-hidden', true);\n\n            // Remove \"inert\" state for focusable elements\n            this.inertElements(false);\n\n            // Set focus to the previous active element\n            this.activeElement.focus();\n        }\n    }, {\n        key: 'trapFocus',\n\n\n        /**\n         * Trap keyboard focus within the modal window.\n         *\n         * @param {Object} e The event object\n         * @return {null}\n         */\n        value: function trapFocus(e) {\n\n            // If the modal is currently visible _and_ the currently focused element\n            // is _not_ within the modal windowâ€¦\n            if (this.modalIsVisible && !this.modalWindow.contains(e.target)) {\n\n                // Stop the event from bubbling any further up into the DOM:\n                // https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation\n                e.stopPropagation();\n\n                // If the user is moving forward, focus on the first element,\n                // otherwise, the `shift` key is pressed; focus on the last element\n                this.shiftKeyIsPressed ? this.lastFocusable.focus() : this.firstFocusable.focus();\n            }\n        }\n    }, {\n        key: 'checkEsc',\n\n\n        /**\n         * Check if the `esc` key has been pressed.\n         *\n         * @param {Object} e The event object\n         * @return {null}\n         */\n        value: function checkEsc(e) {\n            if (this.modalIsVisible) {\n\n                // Hide the modal window on `esc` key press\n                if (e.keyCode === keysCodes.Escape) {\n                    this.hideModal(e);\n                }\n            }\n        }\n    }, {\n        key: 'checkShift',\n\n\n        /**\n         * Check if the `shift` key is being being pressed.\n         *\n         * @param {Object} e The event object\n         * @return {null}\n         */\n        value: function checkShift(e) {\n            if (this.modalIsVisible) {\n\n                // Cache the `shift` key state\n                this.shiftKeyIsPressed = e.shiftKey;\n            }\n        }\n    }, {\n        key: 'hideModalRefocus',\n\n\n        /**\n         * Send focus to the specified element `id` on custom refocus element click\n         *\n         * @param {Object} e The event object\n         * @return {null}\n         */\n        value: function hideModalRefocus(e) {\n            var refocusId = e.target.getAttribute(data.launchyCustom.refocus);\n            var refocusElem = document.querySelector('#' + refocusId);\n\n            // Throw an error if the refocus element is not found\n            if (refocusElem == null) {\n                throw Error(strings.refocusElemNotFound + ': #' + refocusId);\n                return;\n            }\n\n            // Hide the modal\n            this.hideModal(e);\n\n            // Send focus to the specified element\n            refocusElem.focus();\n        }\n    }, {\n        key: 'inertElements',\n\n\n        /**\n         * Set all existing focusable elements as \"inert\" -- hide from screen\n         * readers in order to keep focus trapped within modal when using other\n         * forms of keyboard navigation (other than tab).\n         *\n         * @param {Boolean} inert Flag to set elements \"inert\" state\n         * @return {null}\n         */\n        value: function inertElements(inert) {\n\n            // Select all `data-launchy-focusable` elements\n            var domFocusable = document.querySelectorAll('[' + data.launchyFocusable + ']');\n\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = Array.from(domFocusable)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var domElement = _step5.value;\n\n                    domElement.inert = inert;\n                }\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n        }\n    }]);\n\n    return Launchy;\n}();\n\nvar init = function init() {\n\n    // Create instances per `data-launchy` elements found in the DOM\n    var launchyElements = document.querySelectorAll(selectors.launchyElements);\n\n    var launchyText = null,\n        launchyTitle = null;\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n        for (var _iterator6 = Array.from(launchyElements)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var launchyElement = _step6.value;\n\n            launchyText = launchyElement.getAttribute(data.launchyText), launchyTitle = launchyElement.getAttribute(data.launchyTitle);\n\n            // Throw an error if there's no launcher control text attribute\n            if (!launchyText) {\n                throw Error(strings.modalError);\n                break;\n            }\n\n            // Throw an error if the launcher control text is empty\n            if (launchyText.trim() === '') {\n                throw Error(strings.modalErrorEmpty);\n                break;\n            }\n\n            // Throw a warning if there's no heading title text\n            if (!launchyTitle) {\n                console.warn(strings.modalWarning);\n            }\n\n            // Params object to send to Launchy constructor\n            var params = {\n                target: launchyElement,\n                text: launchyText,\n                title: launchyTitle\n            };\n\n            // Create a new instance for each found in the DOM\n            new Launchy(params);\n        }\n    } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n            }\n        } finally {\n            if (_didIteratorError6) {\n                throw _iteratorError6;\n            }\n        }\n    }\n};\n\ndocument.addEventListener('DOMContentLoaded', init, false);\n\nexports.Launchy = Launchy;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbGF1bmNoeS5qcz9kODA2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGF1bmNoeSEg8J+agCDigJQgQW4gQWNjZXNzaWJsZSBNb2RhbCBXaW5kb3dcbiAqXG4gKiBGZWF0dXJlcyBpbmNsdWRlOlxuICogLSBPbiBsYXVuY2gsIHNoaWZ0IGZvY3VzIHRvIHRoZSBtb2RhbCB3aW5kb3cgY29udGFpbmVyXG4gKiAtIFRoZSBtb2RhbCB3aW5kb3cgaXMgZGVzY3JpYmVkIGJ5IHRoZSBtb2RhbCBoZWFkaW5nXG4gKiAtIFRyYXAga2V5Ym9hcmQgZm9jdXMgd2l0aGluIHRoZSBtb2RhbCB3aGVuIGFjdGl2ZS92aXNpYmxlXG4gKiAtIENsb3NlIHRoZSB3aW5kb3cgb24gYGVzY2Aga2V5IHByZXNzXG4gKiAtIENsb3NlIHRoZSB3aW5kb3cgb24gb3ZlcmxheSBgY2xpY2tgXG4gKiAtIFNldCBrZXlib2FyZCBmb2N1cyBiYWNrIHRvIHRoZSBsYXVuY2hlciBlbGVtZW50IG9uIHdpbmRvdyBjbG9zZVxuICogLSBUcmFuc3BhcmVudCBib3JkZXIgZm9yIFdpbmRvd3MgSGlnaCBDb250cmFzdCB0aGVtZXNcbiAqXG4gKiBDaGVjayBvdXQgdGhlIEdpdEh1YiByZXBvIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vc3ZpbmtsZS9sYXVuY2h5XG4gKlxuICogQGF1dGhvciBTY290dCBWaW5rbGUgPHN2aW5rbGVAZ21haWwuY29tPlxuICogQHZlcnNpb24gMC44LjBcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbmltcG9ydCAnd2ljZy1pbmVydCc7XG5cbi8vIEhUTUwgZWxlbWVudHNcbmNvbnN0IGh0bWxFbGVtZW50cyA9IHtcbiAgICBsYXVuY2hNb2RhbDogJ2EnLFxuICAgIGNsb3NlTW9kYWw6ICdhJyxcbiAgICBtb2RhbFdpbmRvdzogJ2RpdicsXG4gICAgbW9kYWxDb250ZW50OiAnZGl2JyxcbiAgICBtb2RhbE92ZXJsYXk6ICdkaXYnLFxuICAgIG1vZGFsVGl0bGU6ICdoMidcbn07XG5cbi8vIENTUyBjbGFzc2VzXG5jb25zdCBjbGFzc2VzID0ge1xuICAgIG1vZGFsTGF1bmNoTGluazogJ2xhdW5jaHlfX2xhdW5jaC1saW5rJyxcbiAgICBtb2RhbENsb3NlTGluazogJ2xhdW5jaHlfX2Nsb3NlLWxpbmsnLFxuICAgIG1vZGFsV2luZG93OiAnbGF1bmNoeV9fd2luZG93JyxcbiAgICBtb2RhbENvbnRlbnQ6ICdsYXVuY2h5X19jb250ZW50JyxcbiAgICBtb2RhbE92ZXJsYXk6ICdsYXVuY2h5X19vdmVybGF5JyxcbiAgICBtb2RhbFRpdGxlOiAnbGF1bmNoeV9fdGl0bGUnLFxuICAgIG1vZGFsV2luZG93SXNWaXNpYmxlOiAnbGF1bmNoeV9fd2luZG93LS1pcy12aXNpYmxlJyxcbiAgICBtb2RhbE92ZXJsYXlJc1Zpc2libGU6ICdsYXVuY2h5X19vdmVybGF5LS1pcy12aXNpYmxlJ1xufTtcblxuLy8gRGF0YSBhdHRyaWJ1dGVzXG5jb25zdCBkYXRhID0ge1xuICAgIGxhdW5jaHlBcmlhSGlkZGVuOiAnZGF0YS1sYXVuY2h5LWFyaWEtaGlkZGVuJyxcbiAgICBsYXVuY2h5Rm9jdXNhYmxlOiAnZGF0YS1sYXVuY2h5LWZvY3VzYWJsZScsXG4gICAgbGF1bmNoeVRhYkluZGV4OiAnZGF0YS1sYXVuY2h5LXRhYmluZGV4JyxcbiAgICBsYXVuY2h5VGV4dDogJ2RhdGEtbGF1bmNoeS10ZXh0JyxcbiAgICBsYXVuY2h5VGl0bGU6ICdkYXRhLWxhdW5jaHktdGl0bGUnLFxuICAgIGxhdW5jaHlDdXN0b206IHtcbiAgICAgICAgY2xvc2U6ICdkYXRhLWxhdW5jaHktY2xvc2UnLFxuICAgICAgICByZWZvY3VzOiAnZGF0YS1sYXVuY2h5LXJlZm9jdXMnXG4gICAgfVxufTtcblxuLy8gS2V5c1xuY29uc3Qga2V5c0NvZGVzID0ge1xuICAgICdFc2NhcGUnOiAyN1xufTtcblxuLy8gU2VsZWN0b3JzXG5jb25zdCBzZWxlY3RvcnMgPSB7XG4gICAgbGF1bmNoeUVsZW1lbnRzOiAnW2RhdGEtbGF1bmNoeV0nLFxuICAgIGxhdW5jaHlDb250cm9sOiAnbGF1bmNoeS1jb250cm9sLScsXG4gICAgbGF1bmNoeURpYWxvZzogJ2xhdW5jaHktZGlhbG9nLScsXG4gICAgbGF1bmNoeUNsb3NlQ29udHJvbDogJ2xhdW5jaHktY2xvc2UtY29udHJvbC0nLFxuICAgIG1vZGFsT3ZlcmxheTogJ21vZGFsLW92ZXJsYXktJyxcbiAgICBtb2RhbFRpdGxlOiAnbW9kYWwtdGl0bGUtJ1xufTtcblxuLy8gU3RyaW5nc1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgICBtb2RhbENsb3NlOiAnQ2xvc2UgbW9kYWwgd2luZG93IScsXG4gICAgbW9kYWxDbG9zZUhUTUw6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPicsXG4gICAgbW9kYWxFcnJvcjogJ0xhdW5jaHkgY29udGFpbmVyIG11c3QgaGF2ZSBhIGBkYXRhLWxhdW5jaHktdGV4dGAgYXR0cmlidXRlIScsXG4gICAgbW9kYWxFcnJvckVtcHR5OiAnTGF1bmNoeSBjb250YWluZXIgYGRhdGEtbGF1bmNoeS10ZXh0YCBhdHRyaWJ1dGUgY2Fubm90IGJlIGVtcHR5IScsXG4gICAgbW9kYWxXYXJuaW5nOiAnTGF1bmNoeSBjb250YWluZXIgc2hvdWxkIGhhdmUgYSBgZGF0YS1sYXVuY2h5LXRpdGxlYCBhdHRyaWJ1dGUsIG9yIGJlIHN1cmUgdG8gc3VwcGx5IHlvdXIgb3duIGhlYWRpbmchIChQcmVmZXJlYWJseSBhbiBgPGgyPmAuKScsXG4gICAgcmVmb2N1c0VsZW1Ob3RGb3VuZDogJ1JlZm9jdXMgZWxlbWVudCBub3QgZm91bmQhJ1xufTtcblxuLy8gVW5pcXVlIGlkZW50aWZpZXJcbmxldCBsYXVuY2h5SWQgPSAwO1xuXG5jbGFzcyBMYXVuY2h5IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcblxuICAgICAgICAvLyBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9mb2N1c2FibGVcbiAgICAgICAgdGhpcy5mb2N1c2FibGUgPSByZXF1aXJlKCdmb2N1c2FibGUnKTtcblxuICAgICAgICAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgZWFjaCBpbnN0YW5jZVxuICAgICAgICB0aGlzLmxhdW5jaHlJZCA9IGxhdW5jaHlJZDtcblxuICAgICAgICAvLyBGbGFncyBhbmQgb3RoZXIgb2JqZWN0cyB0byBiZSB1c2VkIGxhdGVyXG4gICAgICAgIHRoaXMuaGFzVGl0bGUgPSBwYXJhbXMudGl0bGUgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHRoaXMubW9kYWxJc1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaGlmdEtleUlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbEZvY3VzYWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlyc3RGb2N1c2FibGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RGb2N1c2FibGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbUZvY3VzYWJsZSA9IG51bGw7XG5cbiAgICAgICAgLy8gU2V0dXAgYWxsIHRoZSB0aGluZ3NcbiAgICAgICAgdGhpcy5wcmVwYXJlRm9jdXNhYmxlKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlRWxlbWVudHMocGFyYW1zKTtcbiAgICAgICAgdGhpcy5pbnNlcnRFbGVtZW50cyhwYXJhbXMpO1xuICAgICAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICAvLyBJbmNyZW1lbnQgaWRlbnRpZmllclxuICAgICAgICBsYXVuY2h5SWQrKztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBkYXRhIGF0dHJpYnV0ZSBvbiBhbGwgZXhpc3RpbmcgZm9jdXNhYmxlIGVsZW1lbnRzLiBVc2VkIGluXG4gICAgICogYG1vZGFsSGlkZSgpYCBhbmQgYG1vZGFsU2hvdygpYCB0byBtYWtlIGVsZW1lbnRzIFwiaW5lcnRcIiAtLSBwcmV2ZW50XG4gICAgICogc2NyZWVuIHJlYWRlcnMgZnJvbSByZWFjaGluZyB0aGVzZSBlbGVtZW50cyB3aGVuIHVzaW5nIG90aGVyIG1lYW5zXG4gICAgICogb2YgbmF2aWdhdGlvbiAoYXJyb3cga2V5cywgZm9yIGV4YW1wbGUuKVxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVsbH1cbiAgICAgKi9cbiAgICBwcmVwYXJlRm9jdXNhYmxlKCkge1xuXG4gICAgICAgIC8vIFNlbGVjdCBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBET01cbiAgICAgICAgdGhpcy5kb21Gb2N1c2FibGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuZm9jdXNhYmxlKTtcblxuICAgICAgICAvLyBGb3IgZWFjaCBmb2N1c2FibGUgZWxlbWVudCBpbiB0aGUgRE9NLCBzZXQgdGhlIGRhdGEgYXR0cmlidXRlXG4gICAgICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBBcnJheS5mcm9tKHRoaXMuZG9tRm9jdXNhYmxlKSkge1xuICAgICAgICAgICAgbGV0IGFkZEF0dHJpYnV0ZXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIGB0YWJpbmRleD1cIi0xXCJgXG4gICAgICAgICAgICBpZiAoIWRvbUVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpIHx8IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICE9PSAnLTEnKSB7XG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YS5sYXVuY2h5VGFiSW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgIGFkZEF0dHJpYnV0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBoYXMgYGFyaWEtaGlkZGVuPVwidHJ1ZVwiYFxuICAgICAgICAgICAgaWYgKCFkb21FbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSB8fCBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YS5sYXVuY2h5QXJpYUhpZGRlbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYWRkQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoaXMgZWxlbWVudCB0byB0aGUgc2V0IGlmIHRoZSBhYm92ZSBjb25kaXRpb25zIGFyZSBtZXRcbiAgICAgICAgICAgIGlmIChhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YS5sYXVuY2h5Rm9jdXNhYmxlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbGwgdGhlIHJlcXVpcmVkIGVsZW1lbnRzIGZvciBMYXVuY2h5IHRvIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBJbnN0YW5jZSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybiB7bnVsbH1cbiAgICAgKi9cbiAgICBjcmVhdGVFbGVtZW50cyhwYXJhbXMpIHtcblxuICAgICAgICAvLyBMYXVuY2ggY29udHJvbFxuICAgICAgICB0aGlzLmxhdW5jaENvbnRyb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWxFbGVtZW50cy5sYXVuY2hNb2RhbCk7XG4gICAgICAgIHRoaXMubGF1bmNoQ29udHJvbC5pZCA9IGAke3NlbGVjdG9ycy5sYXVuY2h5Q29udHJvbH0ke3RoaXMubGF1bmNoeUlkfWA7XG4gICAgICAgIHRoaXMubGF1bmNoQ29udHJvbC5ocmVmID0gYCMke3NlbGVjdG9ycy5sYXVuY2h5RGlhbG9nfSR7dGhpcy5sYXVuY2h5SWR9YDtcbiAgICAgICAgdGhpcy5sYXVuY2hDb250cm9sLmNsYXNzTGlzdC5hZGQoY2xhc3Nlcy5tb2RhbExhdW5jaExpbmspO1xuICAgICAgICB0aGlzLmxhdW5jaENvbnRyb2wuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgJ2RpYWxvZycpO1xuICAgICAgICB0aGlzLmxhdW5jaENvbnRyb2wudGV4dENvbnRlbnQgPSBwYXJhbXMudGV4dDtcblxuICAgICAgICAvLyBDbG9zZSBjb250cm9sXG4gICAgICAgIHRoaXMuY2xvc2VDb250cm9sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sRWxlbWVudHMuY2xvc2VNb2RhbCk7XG4gICAgICAgIHRoaXMuY2xvc2VDb250cm9sLmlkID0gYCR7c2VsZWN0b3JzLmxhdW5jaHlDbG9zZUNvbnRyb2x9JHt0aGlzLmxhdW5jaHlJZH1gO1xuICAgICAgICB0aGlzLmNsb3NlQ29udHJvbC5ocmVmID0gYCMke3NlbGVjdG9ycy5sYXVuY2h5Q29udHJvbH0ke3RoaXMubGF1bmNoeUlkfWA7XG4gICAgICAgIHRoaXMuY2xvc2VDb250cm9sLmNsYXNzTGlzdC5hZGQoY2xhc3Nlcy5tb2RhbENsb3NlTGluayk7XG4gICAgICAgIHRoaXMuY2xvc2VDb250cm9sLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHN0cmluZ3MubW9kYWxDbG9zZSk7XG4gICAgICAgIHRoaXMuY2xvc2VDb250cm9sLmlubmVySFRNTCA9IHN0cmluZ3MubW9kYWxDbG9zZUhUTUw7XG5cbiAgICAgICAgLy8gTW9kYWwgd2luZG93XG4gICAgICAgIHRoaXMubW9kYWxXaW5kb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWxFbGVtZW50cy5tb2RhbFdpbmRvdyk7XG4gICAgICAgIHRoaXMubW9kYWxXaW5kb3cuaWQgPSBgJHtzZWxlY3RvcnMubGF1bmNoeURpYWxvZ30ke3RoaXMubGF1bmNoeUlkfWA7XG4gICAgICAgIHRoaXMubW9kYWxXaW5kb3cuY2xhc3NMaXN0LmFkZChjbGFzc2VzLm1vZGFsV2luZG93KTtcbiAgICAgICAgdGhpcy5tb2RhbFdpbmRvdy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xuICAgICAgICB0aGlzLm1vZGFsV2luZG93LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICAgICAgdGhpcy5tb2RhbFdpbmRvdy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNUaXRsZSkge1xuICAgICAgICAgICAgdGhpcy5tb2RhbFdpbmRvdy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScsIGAke3NlbGVjdG9ycy5tb2RhbFRpdGxlfSR7dGhpcy5sYXVuY2h5SWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb2RhbCBvdmVybGF5XG4gICAgICAgIHRoaXMubW9kYWxPdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sRWxlbWVudHMubW9kYWxPdmVybGF5KTtcbiAgICAgICAgdGhpcy5tb2RhbE92ZXJsYXkuaWQgPSBgJHtzZWxlY3RvcnMubW9kYWxPdmVybGF5fSR7dGhpcy5sYXVuY2h5SWR9YDtcbiAgICAgICAgdGhpcy5tb2RhbE92ZXJsYXkuY2xhc3NMaXN0LmFkZChjbGFzc2VzLm1vZGFsT3ZlcmxheSk7XG4gICAgICAgIHRoaXMubW9kYWxPdmVybGF5LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcblxuICAgICAgICAvLyBNb2RhbCBjb250ZW50XG4gICAgICAgIHRoaXMubW9kYWxDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sRWxlbWVudHMubW9kYWxDb250ZW50KTtcbiAgICAgICAgdGhpcy5tb2RhbENvbnRlbnQuY2xhc3NMaXN0LmFkZChjbGFzc2VzLm1vZGFsQ29udGVudCk7XG5cbiAgICAgICAgLy8gTW9kYWwgdGl0bGVcbiAgICAgICAgaWYgKHRoaXMuaGFzVGl0bGUpIHtcbiAgICAgICAgICAgIHRoaXMubW9kYWxUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbEVsZW1lbnRzLm1vZGFsVGl0bGUpO1xuICAgICAgICAgICAgdGhpcy5tb2RhbFRpdGxlLmlkID0gYCR7c2VsZWN0b3JzLm1vZGFsVGl0bGV9JHt0aGlzLmxhdW5jaHlJZH1gO1xuICAgICAgICAgICAgdGhpcy5tb2RhbFRpdGxlLmNsYXNzTGlzdC5hZGQoY2xhc3Nlcy5tb2RhbFRpdGxlKTtcbiAgICAgICAgICAgIHRoaXMubW9kYWxUaXRsZS50ZXh0Q29udGVudCA9IHBhcmFtcy50aXRsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBMYXVuY2h5IGVsZW1lbnRzIGludG8gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgaW5zdGFuY2UgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm4ge251bGx9XG4gICAgICovXG4gICAgaW5zZXJ0RWxlbWVudHMocGFyYW1zKSB7XG5cbiAgICAgICAgLy8gU2VsZWN0IGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIG1vZGFsIGNvbnRlbnRcbiAgICAgICAgY29uc3QgZG9tRm9jdXNhYmxlID0gcGFyYW1zLnRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuZm9jdXNhYmxlKTtcblxuICAgICAgICAvLyBMYXVuY2ggY29udHJvbFxuICAgICAgICBwYXJhbXMudGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubGF1bmNoQ29udHJvbCwgcGFyYW1zLnRhcmdldCk7XG5cbiAgICAgICAgLy8gTW9kYWwgd2luZG93XG4gICAgICAgIHBhcmFtcy50YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5tb2RhbFdpbmRvdywgcGFyYW1zLnRhcmdldCk7XG5cbiAgICAgICAgLy8gTW9kYWwgY29udGVudCBjb250YWluZXJcbiAgICAgICAgdGhpcy5tb2RhbFdpbmRvdy5hcHBlbmRDaGlsZCh0aGlzLm1vZGFsQ29udGVudCk7XG5cbiAgICAgICAgLy8gQ2xvc2UgY29udHJvbFxuICAgICAgICB0aGlzLm1vZGFsQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmNsb3NlQ29udHJvbCk7XG5cbiAgICAgICAgLy8gTW9kYWwgdGl0bGVcbiAgICAgICAgaWYgKHRoaXMuaGFzVGl0bGUpIHtcbiAgICAgICAgICAgIHRoaXMubW9kYWxDb250ZW50LmFwcGVuZENoaWxkKHRoaXMubW9kYWxUaXRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlIHRoZSBjb250ZW50IHdpdGhpbiB0aGUgbW9kYWwgY29udGFpbmVyXG4gICAgICAgIHRoaXMubW9kYWxDb250ZW50LmFwcGVuZENoaWxkKHBhcmFtcy50YXJnZXQpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBgZGF0YS1sYXVuY2h5LWZvY3VzYWJsZWAgZnJvbSBhbnkgZWxlbWVudHMgd2l0aGluIHRoZVxuICAgICAgICAvLyBtb2RhbCBjb250ZW50IC0tIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGVzZSBpbmVydFxuICAgICAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgQXJyYXkuZnJvbShkb21Gb2N1c2FibGUpKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShkYXRhLmxhdW5jaHlBcmlhSGlkZGVuKTtcbiAgICAgICAgICAgIGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGRhdGEubGF1bmNoeUZvY3VzYWJsZSk7XG4gICAgICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShkYXRhLmxhdW5jaHlUYWJJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdmVybGF5XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5tb2RhbE92ZXJsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBldmVudCBsaXN0ZW5lcnMgZm9yIExhdW5jaHkgZnVuY3Rpb25hbGl0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bGx9XG4gICAgICovXG4gICAgc2V0dXBFdmVudExpc3RlbmVycygpIHtcblxuICAgICAgICAvLyBHYXRoZXIgYW55IGN1c3RvbSBjbG9zZSBvciByZWZvY3VzIGNvbnRyb2xzXG4gICAgICAgIGNvbnN0IGNsb3NlQ29udHJvbHMgPSB0aGlzLm1vZGFsQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKGBbJHtkYXRhLmxhdW5jaHlDdXN0b20uY2xvc2V9XWApO1xuICAgICAgICBjb25zdCByZWZvY3VzQ29udHJvbHMgPSB0aGlzLm1vZGFsQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKGBbJHtkYXRhLmxhdW5jaHlDdXN0b20ucmVmb2N1c31dYCk7XG5cbiAgICAgICAgLy8gU2hvdyB0aGUgbW9kYWwgd2luZG93IG9uIHRoZSBsYXVuY2hlciBlbGVtZW50IGBjbGlja2AgZXZlbnRcbiAgICAgICAgdGhpcy5sYXVuY2hDb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zaG93TW9kYWwuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIEhpZGUgdGhlIG1vZGFsIHdpbmRvdyBvbiBjbG9zZSBidXR0b24gb3Igb3ZlcmxheSBgY2xpY2tgIGV2ZW50XG4gICAgICAgIHRoaXMuY2xvc2VDb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oaWRlTW9kYWwuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICB0aGlzLm1vZGFsT3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGlkZU1vZGFsLmJpbmQodGhpcyksIGZhbHNlKTtcblxuICAgICAgICAvLyBUcmFwIHRoZSBrZXlib2FyZCBmb2N1cyB3aXRoaW4gbW9kYWwgd2luZG93IG9uIHRoZSBkb2N1bWVudFxuICAgICAgICAvLyBgZm9jdXNgIGV2ZW50LiBOb3RpY2UgdGhlIHVzZSBvZiB0aGUgYHVzZUNhcHR1cmVgIGZsYWcgc2V0IHRvIGB0cnVlYDsgdGhpc1xuICAgICAgICAvLyBpbmRpY2F0ZXMgdGhlIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byB0aGUgbGlzdGVuZXIgYmVmb3JlIGFueSBldmVudFxuICAgICAgICAvLyB0YXJnZXQgaW4gdGhlIERPTTpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnRyYXBGb2N1cy5iaW5kKHRoaXMpLCB0cnVlKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgYGVzY2Aga2V5IHByZXNzIG9uIHRoZSBkb2N1bWVudCBga2V5ZG93bmAgZXZlbnRcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuY2hlY2tFc2MuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBgc2hpZnRgIGtleSBwcmVzcyBvbiB0aGUgZG9jdW1lbnQgYGtleWRvd25gIGV2ZW50XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmNoZWNrU2hpZnQuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciBmb3IgYWxsIGN1c3RvbSBjbG9zZSBjb250cm9sc1xuICAgICAgICBmb3IgKGNvbnN0IGNsb3NlQ29udHJvbCBvZiBBcnJheS5mcm9tKGNsb3NlQ29udHJvbHMpKSB7XG4gICAgICAgICAgICBjbG9zZUNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhpZGVNb2RhbC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIGFsbCBjdXN0b20gcmVmb2N1cyBjb250cm9sc1xuICAgICAgICBmb3IgKGNvbnN0IHJlZm9jdXNDb250cm9sIG9mIEFycmF5LmZyb20ocmVmb2N1c0NvbnRyb2xzKSkge1xuICAgICAgICAgICAgcmVmb2N1c0NvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhpZGVNb2RhbFJlZm9jdXMuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgbW9kYWwgd2luZG93LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IG9iamVjdFxuICAgICAqIEByZXR1cm4ge251bGx9XG4gICAgICovXG4gICAgc2hvd01vZGFsKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSBsYXN0IGFjdGl2ZSBlbGVtZW50XG4gICAgICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgLy8gU2V0IHZpc2libGUgZmxhZyBhcyBgdHJ1ZWBcbiAgICAgICAgdGhpcy5tb2RhbElzVmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBmb2N1c2FibGUgb2JqZWN0cywgZmlyc3QgYW5kIGxhc3QsIHdpdGhpbiB0aGUgbW9kYWwgd2luZG93XG4gICAgICAgIHRoaXMuYWxsRm9jdXNhYmxlID0gdGhpcy5tb2RhbFdpbmRvdy5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuZm9jdXNhYmxlKTtcbiAgICAgICAgdGhpcy5maXJzdEZvY3VzYWJsZSA9IHRoaXMuYWxsRm9jdXNhYmxlWzBdO1xuICAgICAgICB0aGlzLmxhc3RGb2N1c2FibGUgPSB0aGlzLmFsbEZvY3VzYWJsZVt0aGlzLmFsbEZvY3VzYWJsZS5sZW5ndGggLSAxXTtcblxuICAgICAgICAvLyBBZGQgdGhlIGBhY3RpdmVgIGNsYXNzZXMgYW5kIHNldCBgYXJpYS1oaWRkZW5gIHRvIGBmYWxzZWBcbiAgICAgICAgdGhpcy5tb2RhbFdpbmRvdy5jbGFzc0xpc3QuYWRkKGNsYXNzZXMubW9kYWxXaW5kb3dJc1Zpc2libGUpO1xuICAgICAgICB0aGlzLm1vZGFsT3ZlcmxheS5jbGFzc0xpc3QuYWRkKGNsYXNzZXMubW9kYWxPdmVybGF5SXNWaXNpYmxlKTtcbiAgICAgICAgdGhpcy5tb2RhbFdpbmRvdy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgZmFsc2UpO1xuXG4gICAgICAgIC8vIFNldCBmb2N1c2FibGUgZWxlbWVudHMgYXMgXCJpbmVydFwiXG4gICAgICAgIHRoaXMuaW5lcnRFbGVtZW50cyh0cnVlKTtcblxuICAgICAgICAvLyBTaGlmdCBrZXlib2FyZCBmb2N1cyB0byB0aGUgbW9kYWwgd2luZG93IGNvbnRhaW5lclxuICAgICAgICB0aGlzLm1vZGFsV2luZG93LmZvY3VzKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIG1vZGFsIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtudWxsfVxuICAgICAqL1xuICAgIGhpZGVNb2RhbChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBTZXQgdmlzaWJsZSBmbGFnIHRvIGBmYWxzZWBcbiAgICAgICAgdGhpcy5tb2RhbElzVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBmb2N1c2FibGUgb2JqZWN0c1xuICAgICAgICB0aGlzLmFsbEZvY3VzYWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlyc3RGb2N1c2FibGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RGb2N1c2FibGUgPSBudWxsO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgYGFjdGl2ZWAgY2xhc3NlcyBhbmQgc2V0IGBhcmlhLWhpZGRlbmAgdG8gYHRydWVgXG4gICAgICAgIHRoaXMubW9kYWxXaW5kb3cuY2xhc3NMaXN0LnJlbW92ZShjbGFzc2VzLm1vZGFsV2luZG93SXNWaXNpYmxlKTtcbiAgICAgICAgdGhpcy5tb2RhbE92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc2VzLm1vZGFsT3ZlcmxheUlzVmlzaWJsZSk7XG4gICAgICAgIHRoaXMubW9kYWxXaW5kb3cuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBcImluZXJ0XCIgc3RhdGUgZm9yIGZvY3VzYWJsZSBlbGVtZW50c1xuICAgICAgICB0aGlzLmluZXJ0RWxlbWVudHMoZmFsc2UpO1xuXG4gICAgICAgIC8vIFNldCBmb2N1cyB0byB0aGUgcHJldmlvdXMgYWN0aXZlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5hY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyYXAga2V5Ym9hcmQgZm9jdXMgd2l0aGluIHRoZSBtb2RhbCB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgb2JqZWN0XG4gICAgICogQHJldHVybiB7bnVsbH1cbiAgICAgKi9cbiAgICB0cmFwRm9jdXMoZSkge1xuXG4gICAgICAgIC8vIElmIHRoZSBtb2RhbCBpcyBjdXJyZW50bHkgdmlzaWJsZSBfYW5kXyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAvLyBpcyBfbm90XyB3aXRoaW4gdGhlIG1vZGFsIHdpbmRvd+KAplxuICAgICAgICBpZiAodGhpcy5tb2RhbElzVmlzaWJsZSAmJiAhdGhpcy5tb2RhbFdpbmRvdy5jb250YWlucyhlLnRhcmdldCkpIHtcblxuICAgICAgICAgICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBidWJibGluZyBhbnkgZnVydGhlciB1cCBpbnRvIHRoZSBET006XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnQvc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBtb3ZpbmcgZm9yd2FyZCwgZm9jdXMgb24gdGhlIGZpcnN0IGVsZW1lbnQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBgc2hpZnRgIGtleSBpcyBwcmVzc2VkOyBmb2N1cyBvbiB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLnNoaWZ0S2V5SXNQcmVzc2VkID8gdGhpcy5sYXN0Rm9jdXNhYmxlLmZvY3VzKCkgOiB0aGlzLmZpcnN0Rm9jdXNhYmxlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGBlc2NgIGtleSBoYXMgYmVlbiBwcmVzc2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IG9iamVjdFxuICAgICAqIEByZXR1cm4ge251bGx9XG4gICAgICovXG4gICAgY2hlY2tFc2MoZSkge1xuICAgICAgICBpZiAodGhpcy5tb2RhbElzVmlzaWJsZSkge1xuXG4gICAgICAgICAgICAvLyBIaWRlIHRoZSBtb2RhbCB3aW5kb3cgb24gYGVzY2Aga2V5IHByZXNzXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlzQ29kZXMuRXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlTW9kYWwoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGBzaGlmdGAga2V5IGlzIGJlaW5nIGJlaW5nIHByZXNzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgb2JqZWN0XG4gICAgICogQHJldHVybiB7bnVsbH1cbiAgICAgKi9cbiAgICBjaGVja1NoaWZ0KGUpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kYWxJc1Zpc2libGUpIHtcblxuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGBzaGlmdGAga2V5IHN0YXRlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0S2V5SXNQcmVzc2VkID0gZS5zaGlmdEtleTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGZvY3VzIHRvIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBgaWRgIG9uIGN1c3RvbSByZWZvY3VzIGVsZW1lbnQgY2xpY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtudWxsfVxuICAgICAqL1xuICAgIGhpZGVNb2RhbFJlZm9jdXMoZSkge1xuICAgICAgICBjb25zdCByZWZvY3VzSWQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoZGF0YS5sYXVuY2h5Q3VzdG9tLnJlZm9jdXMpO1xuICAgICAgICBjb25zdCByZWZvY3VzRWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke3JlZm9jdXNJZH1gKTtcblxuICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiB0aGUgcmVmb2N1cyBlbGVtZW50IGlzIG5vdCBmb3VuZFxuICAgICAgICBpZiAocmVmb2N1c0VsZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYCR7c3RyaW5ncy5yZWZvY3VzRWxlbU5vdEZvdW5kfTogIyR7cmVmb2N1c0lkfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGlkZSB0aGUgbW9kYWxcbiAgICAgICAgdGhpcy5oaWRlTW9kYWwoZSk7XG5cbiAgICAgICAgLy8gU2VuZCBmb2N1cyB0byB0aGUgc3BlY2lmaWVkIGVsZW1lbnRcbiAgICAgICAgcmVmb2N1c0VsZW0uZm9jdXMoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGFsbCBleGlzdGluZyBmb2N1c2FibGUgZWxlbWVudHMgYXMgXCJpbmVydFwiIC0tIGhpZGUgZnJvbSBzY3JlZW5cbiAgICAgKiByZWFkZXJzIGluIG9yZGVyIHRvIGtlZXAgZm9jdXMgdHJhcHBlZCB3aXRoaW4gbW9kYWwgd2hlbiB1c2luZyBvdGhlclxuICAgICAqIGZvcm1zIG9mIGtleWJvYXJkIG5hdmlnYXRpb24gKG90aGVyIHRoYW4gdGFiKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5lcnQgRmxhZyB0byBzZXQgZWxlbWVudHMgXCJpbmVydFwiIHN0YXRlXG4gICAgICogQHJldHVybiB7bnVsbH1cbiAgICAgKi9cbiAgICBpbmVydEVsZW1lbnRzKGluZXJ0KSB7XG5cbiAgICAgICAgLy8gU2VsZWN0IGFsbCBgZGF0YS1sYXVuY2h5LWZvY3VzYWJsZWAgZWxlbWVudHNcbiAgICAgICAgY29uc3QgZG9tRm9jdXNhYmxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgWyR7ZGF0YS5sYXVuY2h5Rm9jdXNhYmxlfV1gKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgQXJyYXkuZnJvbShkb21Gb2N1c2FibGUpKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50LmluZXJ0ID0gaW5lcnQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5jb25zdCBpbml0ID0gKCkgPT4ge1xuXG4gICAgLy8gQ3JlYXRlIGluc3RhbmNlcyBwZXIgYGRhdGEtbGF1bmNoeWAgZWxlbWVudHMgZm91bmQgaW4gdGhlIERPTVxuICAgIGNvbnN0IGxhdW5jaHlFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzLmxhdW5jaHlFbGVtZW50cyk7XG5cbiAgICBsZXQgbGF1bmNoeVRleHQgPSBudWxsLFxuICAgICAgICBsYXVuY2h5VGl0bGUgPSBudWxsO1xuXG4gICAgZm9yIChjb25zdCBsYXVuY2h5RWxlbWVudCBvZiBBcnJheS5mcm9tKGxhdW5jaHlFbGVtZW50cykpIHtcbiAgICAgICAgbGF1bmNoeVRleHQgPSBsYXVuY2h5RWxlbWVudC5nZXRBdHRyaWJ1dGUoZGF0YS5sYXVuY2h5VGV4dCksXG4gICAgICAgIGxhdW5jaHlUaXRsZSA9IGxhdW5jaHlFbGVtZW50LmdldEF0dHJpYnV0ZShkYXRhLmxhdW5jaHlUaXRsZSk7XG5cbiAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUncyBubyBsYXVuY2hlciBjb250cm9sIHRleHQgYXR0cmlidXRlXG4gICAgICAgIGlmICghbGF1bmNoeVRleHQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKHN0cmluZ3MubW9kYWxFcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBsYXVuY2hlciBjb250cm9sIHRleHQgaXMgZW1wdHlcbiAgICAgICAgaWYgKGxhdW5jaHlUZXh0LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKHN0cmluZ3MubW9kYWxFcnJvckVtcHR5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhyb3cgYSB3YXJuaW5nIGlmIHRoZXJlJ3Mgbm8gaGVhZGluZyB0aXRsZSB0ZXh0XG4gICAgICAgIGlmICghbGF1bmNoeVRpdGxlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oc3RyaW5ncy5tb2RhbFdhcm5pbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyYW1zIG9iamVjdCB0byBzZW5kIHRvIExhdW5jaHkgY29uc3RydWN0b3JcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiBsYXVuY2h5RWxlbWVudCxcbiAgICAgICAgICAgIHRleHQ6IGxhdW5jaHlUZXh0LFxuICAgICAgICAgICAgdGl0bGU6IGxhdW5jaHlUaXRsZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBmb3IgZWFjaCBmb3VuZCBpbiB0aGUgRE9NXG4gICAgICAgIG5ldyBMYXVuY2h5KHBhcmFtcyk7XG4gICAgfVxufTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGluaXQsIGZhbHNlKTtcblxuZXhwb3J0IHtMYXVuY2h5fTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvbGF1bmNoeS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQU5BO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQTBCQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTFCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBMkJBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUEyQkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUEvQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQWdDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBbENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFtQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFBOzs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUF0Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!***********************************************!*\
  !*** ./node_modules/wicg-inert/dist/inert.js ***!
  \***********************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(factory());\n}(this, (function () { 'use strict';\n\n/**\n * Determine if a DOM element matches a CSS selector\n *\n * @param {Element} elem\n * @param {String} selector\n * @return {Boolean}\n * @api public\n */\n\nfunction matches(elem, selector) {\n  // Vendor-specific implementations of `Element.prototype.matches()`.\n  var proto = window.Element.prototype;\n  var nativeMatches = proto.matches ||\n      proto.mozMatchesSelector ||\n      proto.msMatchesSelector ||\n      proto.oMatchesSelector ||\n      proto.webkitMatchesSelector;\n\n  if (!elem || elem.nodeType !== 1) {\n    return false;\n  }\n\n  var parentElem = elem.parentNode;\n\n  // use native 'matches'\n  if (nativeMatches) {\n    return nativeMatches.call(elem, selector);\n  }\n\n  // native support for `matches` is missing and a fallback is required\n  var nodes = parentElem.querySelectorAll(selector);\n  var len = nodes.length;\n\n  for (var i = 0; i < len; i++) {\n    if (nodes[i] === elem) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Expose `matches`\n */\n\nvar index = matches;\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n/**\n * This work is licensed under the W3C Software and Document License\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\n */\n\n(function (document) {\n  // Convenience function for converting NodeLists.\n  /** @type {function(number,number):Array} */\n  var slice = Array.prototype.slice;\n\n  /** @type {string} */\n  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n\n  /**\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\n   * attribute.\n   *\n   * Its main functions are:\n   *\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\n   *\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\n   *   `deregister` method on `InertManager` for each managed inert node.\n   */\n\n  var InertRoot = function () {\n    /**\n     * @param {Element} rootElement The Element at the root of the inert subtree.\n     * @param {InertManager} inertManager The global singleton InertManager object.\n     */\n    function InertRoot(rootElement, inertManager) {\n      classCallCheck(this, InertRoot);\n\n      /** @type {InertManager} */\n      this._inertManager = inertManager;\n\n      /** @type {Element} */\n      this._rootElement = rootElement;\n\n      /**\n       * @type {Set<Node>}\n       * All managed focusable nodes in this InertRoot's subtree.\n       */\n      this._managedNodes = new Set([]);\n\n      // Make the subtree hidden from assistive technology\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      }\n      this._rootElement.setAttribute('aria-hidden', 'true');\n\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n      this._makeSubtreeUnfocusable(this._rootElement);\n\n      // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n      this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\n     * stored in this object and updates the state of all of the managed nodes.\n     */\n\n\n    createClass(InertRoot, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._observer.disconnect();\n        this._observer = null;\n\n        if (this._rootElement) {\n          if (this.hasSavedAriaHidden) {\n            this._rootElement.setAttribute('aria-hidden', this.savedAriaHidden);\n          } else {\n            this._rootElement.removeAttribute('aria-hidden');\n          }\n        }\n        this._rootElement = null;\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this._managedNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var inertNode = _step.value;\n\n            this._unmanageNode(inertNode.node);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        this._managedNodes = null;\n\n        this._inertManager = null;\n      }\n\n      /**\n       * @return {Set<InertNode>} A copy of this InertRoot's managed nodes set.\n       */\n\n    }, {\n      key: '_makeSubtreeUnfocusable',\n\n\n      /**\n       * @param {Node} startNode\n       */\n      value: function _makeSubtreeUnfocusable(startNode) {\n        var _this = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this._visitNode(node);\n        });\n\n        var activeElement = document.activeElement;\n        if (!contains(document.body, startNode)) {\n          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n          var node = startNode;\n          var root = undefined;\n          while (node) {\n            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n              root = node;\n              break;\n            }\n            node = node.parentNode;\n          }\n          if (root) {\n            activeElement = root.activeElement;\n          }\n        }\n        if (contains(startNode, activeElement)) {\n          activeElement.blur();\n        }\n      }\n\n      /**\n       * @param {Node} node\n       */\n\n    }, {\n      key: '_visitNode',\n      value: function _visitNode(node) {\n        if (node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n\n        // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n        if (node !== this._rootElement && node.hasAttribute('inert')) {\n          this._adoptInertRoot(node);\n        }\n\n        if (index(node, _focusableElementsString) || node.hasAttribute('tabindex')) {\n          this._manageNode(node);\n        }\n      }\n\n      /**\n       * Register the given node with this InertRoot and with InertManager.\n       * @param {Node} node\n       */\n\n    }, {\n      key: '_manageNode',\n      value: function _manageNode(node) {\n        var inertNode = this._inertManager.register(node, this);\n        this._managedNodes.add(inertNode);\n      }\n\n      /**\n       * Unregister the given node with this InertRoot and with InertManager.\n       * @param {Node} node\n       */\n\n    }, {\n      key: '_unmanageNode',\n      value: function _unmanageNode(node) {\n        var inertNode = this._inertManager.deregister(node, this);\n        if (inertNode) {\n          this._managedNodes.delete(inertNode);\n        }\n      }\n\n      /**\n       * Unregister the entire subtree starting at `startNode`.\n       * @param {Node} startNode\n       */\n\n    }, {\n      key: '_unmanageSubtree',\n      value: function _unmanageSubtree(startNode) {\n        var _this2 = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this2._unmanageNode(node);\n        });\n      }\n\n      /**\n       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\n       * @param {Node} node\n       */\n\n    }, {\n      key: '_adoptInertRoot',\n      value: function _adoptInertRoot(node) {\n        var inertSubroot = this._inertManager.getInertRoot(node);\n\n        // During initialisation this inert root may not have been registered yet,\n        // so register it now if need be.\n        if (!inertSubroot) {\n          this._inertManager.setInert(node, true);\n          inertSubroot = this._inertManager.getInertRoot(node);\n        }\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = inertSubroot.managedNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var savedInertNode = _step2.value;\n\n            this._manageNode(savedInertNode.node);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      /**\n       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\n       * @param {MutationRecord} records\n       * @param {MutationObserver} self\n       */\n\n    }, {\n      key: '_onMutation',\n      value: function _onMutation(records, self) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = records[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var record = _step3.value;\n\n            var target = record.target;\n            if (record.type === 'childList') {\n              // Manage added nodes\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n\n              try {\n                for (var _iterator4 = slice.call(record.addedNodes)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  var node = _step4.value;\n\n                  this._makeSubtreeUnfocusable(node);\n                }\n\n                // Un-manage removed nodes\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n\n              var _iteratorNormalCompletion5 = true;\n              var _didIteratorError5 = false;\n              var _iteratorError5 = undefined;\n\n              try {\n                for (var _iterator5 = slice.call(record.removedNodes)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                  var _node = _step5.value;\n\n                  this._unmanageSubtree(_node);\n                }\n              } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                    _iterator5.return();\n                  }\n                } finally {\n                  if (_didIteratorError5) {\n                    throw _iteratorError5;\n                  }\n                }\n              }\n            } else if (record.type === 'attributes') {\n              if (record.attributeName === 'tabindex') {\n                // Re-initialise inert node if tabindex changes\n                this._manageNode(target);\n              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n                // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n                // already managed nodes from this inert subroot.\n                this._adoptInertRoot(target);\n                var inertSubroot = this._inertManager.getInertRoot(target);\n                var _iteratorNormalCompletion6 = true;\n                var _didIteratorError6 = false;\n                var _iteratorError6 = undefined;\n\n                try {\n                  for (var _iterator6 = this._managedNodes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var managedNode = _step6.value;\n\n                    if (contains(target, managedNode.node)) {\n                      inertSubroot._manageNode(managedNode.node);\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError6 = true;\n                  _iteratorError6 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                      _iterator6.return();\n                    }\n                  } finally {\n                    if (_didIteratorError6) {\n                      throw _iteratorError6;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    }, {\n      key: 'managedNodes',\n      get: function get$$1() {\n        return new Set(this._managedNodes);\n      }\n\n      /** @return {boolean} */\n\n    }, {\n      key: 'hasSavedAriaHidden',\n      get: function get$$1() {\n        return '_savedAriaHidden' in this;\n      }\n\n      /** @param {string} ariaHidden */\n\n    }, {\n      key: 'savedAriaHidden',\n      set: function set$$1(ariaHidden) {\n        this._savedAriaHidden = ariaHidden;\n      }\n\n      /** @return {string} */\n      ,\n      get: function get$$1() {\n        return this._savedAriaHidden;\n      }\n    }]);\n    return InertRoot;\n  }();\n\n  /**\n   * `InertNode` initialises and manages a single inert node.\n   * A node is inert if it is a descendant of one or more inert root elements.\n   *\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\n   * is intrinsically focusable or not.\n   *\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\n   */\n\n\n  var InertNode = function () {\n    /**\n     * @param {Node} node A focusable element to be made inert.\n     * @param {InertRoot} inertRoot The inert root element associated with this inert node.\n     */\n    function InertNode(node, inertRoot) {\n      classCallCheck(this, InertNode);\n\n      /** @type {Node} */\n      this._node = node;\n\n      /** @type {boolean} */\n      this._overrodeFocusMethod = false;\n\n      /**\n       * @type {Set<InertRoot>} The set of descendant inert roots.\n       *    If and only if this set becomes empty, this node is no longer inert.\n       */\n      this._inertRoots = new Set([inertRoot]);\n\n      /** @type {boolean} */\n      this._destroyed = false;\n\n      // Save any prior tabindex info and make this node untabbable\n      this.ensureUntabbable();\n    }\n\n    /**\n     * Call this whenever this object is about to become obsolete.\n     * This makes the managed node focusable again and deletes all of the previously stored state.\n     */\n\n\n    createClass(InertNode, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._throwIfDestroyed();\n\n        if (this._node) {\n          if (this.hasSavedTabIndex) {\n            this._node.setAttribute('tabindex', this.savedTabIndex);\n          } else {\n            this._node.removeAttribute('tabindex');\n          }\n\n          // Use `delete` to restore native focus method.\n          if (this._overrodeFocusMethod) {\n            delete this._node.focus;\n          }\n        }\n        this._node = null;\n        this._inertRoots = null;\n\n        this._destroyed = true;\n      }\n\n      /**\n       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\n       * If the object has been destroyed, any attempt to access it will cause an exception.\n       */\n\n    }, {\n      key: '_throwIfDestroyed',\n\n\n      /**\n       * Throw if user tries to access destroyed InertNode.\n       */\n      value: function _throwIfDestroyed() {\n        if (this.destroyed) {\n          throw new Error('Trying to access destroyed InertNode');\n        }\n      }\n\n      /** @return {boolean} */\n\n    }, {\n      key: 'ensureUntabbable',\n\n\n      /** Save the existing tabindex value and make the node untabbable and unfocusable */\n      value: function ensureUntabbable() {\n        var node = this.node;\n        if (index(node, _focusableElementsString)) {\n          if (node.tabIndex === -1 && this.hasSavedTabIndex) {\n            return;\n          }\n\n          if (node.hasAttribute('tabindex')) {\n            this._savedTabIndex = node.tabIndex;\n          }\n          node.setAttribute('tabindex', '-1');\n          if (node.nodeType === Node.ELEMENT_NODE) {\n            node.focus = function () {};\n            this._overrodeFocusMethod = true;\n          }\n        } else if (node.hasAttribute('tabindex')) {\n          this._savedTabIndex = node.tabIndex;\n          node.removeAttribute('tabindex');\n        }\n      }\n\n      /**\n       * Add another inert root to this inert node's set of managing inert roots.\n       * @param {InertRoot} inertRoot\n       */\n\n    }, {\n      key: 'addInertRoot',\n      value: function addInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots.add(inertRoot);\n      }\n\n      /**\n       * Remove the given inert root from this inert node's set of managing inert roots.\n       * If the set of managing inert roots becomes empty, this node is no longer inert,\n       * so the object should be destroyed.\n       * @param {InertRoot} inertRoot\n       */\n\n    }, {\n      key: 'removeInertRoot',\n      value: function removeInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n        this._inertRoots.delete(inertRoot);\n        if (this._inertRoots.size === 0) {\n          this.destructor();\n        }\n      }\n    }, {\n      key: 'destroyed',\n      get: function get$$1() {\n        return this._destroyed;\n      }\n    }, {\n      key: 'hasSavedTabIndex',\n      get: function get$$1() {\n        return '_savedTabIndex' in this;\n      }\n\n      /** @return {Node} */\n\n    }, {\n      key: 'node',\n      get: function get$$1() {\n        this._throwIfDestroyed();\n        return this._node;\n      }\n\n      /** @param {number} tabIndex */\n\n    }, {\n      key: 'savedTabIndex',\n      set: function set$$1(tabIndex) {\n        this._throwIfDestroyed();\n        this._savedTabIndex = tabIndex;\n      }\n\n      /** @return {number} */\n      ,\n      get: function get$$1() {\n        this._throwIfDestroyed();\n        return this._savedTabIndex;\n      }\n    }]);\n    return InertNode;\n  }();\n\n  /**\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\n   *\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\n   * is created for each such node, via the `_managedNodes` map.\n   */\n\n\n  var InertManager = function () {\n    /**\n     * @param {Document} document\n     */\n    function InertManager(document) {\n      classCallCheck(this, InertManager);\n\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n\n      /** @type {Document} */\n      this._document = document;\n\n      /**\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\n       * @type {Map<Node, InertNode>}\n       */\n      this._managedNodes = new Map();\n\n      /**\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\n       * @type {Map<Node, InertRoot>}\n       */\n      this._inertRoots = new Map();\n\n      /**\n       * Observer for mutations on `document.body`.\n       * @type {MutationObserver}\n       */\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\n\n      // Add inert style.\n      addInertStyle(document.head || document.body || document.documentElement);\n\n      // Wait for document to be loaded.\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n\n    /**\n     * Set whether the given element should be an inert root or not.\n     * @param {Element} root\n     * @param {boolean} inert\n     */\n\n\n    createClass(InertManager, [{\n      key: 'setInert',\n      value: function setInert(root, inert) {\n        if (inert) {\n          if (this._inertRoots.has(root)) {\n            // element is already inert\n            return;\n          }\n\n          var inertRoot = new InertRoot(root, this);\n          root.setAttribute('inert', '');\n          this._inertRoots.set(root, inertRoot);\n          // If not contained in the document, it must be in a shadowRoot.\n          // Ensure inert styles are added there.\n          if (!contains(this._document.body, root)) {\n            var parent = root.parentNode;\n            while (parent) {\n              if (parent.nodeType === 11) {\n                addInertStyle(parent);\n              }\n              parent = parent.parentNode;\n            }\n          }\n        } else {\n          if (!this._inertRoots.has(root)) {\n            // element is already non-inert\n            return;\n          }\n\n          var _inertRoot = this._inertRoots.get(root);\n          _inertRoot.destructor();\n          this._inertRoots.delete(root);\n          root.removeAttribute('inert');\n        }\n      }\n\n      /**\n       * Get the InertRoot object corresponding to the given inert root element, if any.\n       * @param {Element} element\n       * @return {InertRoot?}\n       */\n\n    }, {\n      key: 'getInertRoot',\n      value: function getInertRoot(element) {\n        return this._inertRoots.get(element);\n      }\n\n      /**\n       * Register the given InertRoot as managing the given node.\n       * In the case where the node has a previously existing inert root, this inert root will\n       * be added to its set of inert roots.\n       * @param {Node} node\n       * @param {InertRoot} inertRoot\n       * @return {InertNode} inertNode\n       */\n\n    }, {\n      key: 'register',\n      value: function register(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (inertNode !== undefined) {\n          // node was already in an inert subtree\n          inertNode.addInertRoot(inertRoot);\n          // Update saved tabindex value if necessary\n          inertNode.ensureUntabbable();\n        } else {\n          inertNode = new InertNode(node, inertRoot);\n        }\n\n        this._managedNodes.set(node, inertNode);\n\n        return inertNode;\n      }\n\n      /**\n       * De-register the given InertRoot as managing the given inert node.\n       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\n       * node from the InertManager's set of managed nodes if it is destroyed.\n       * If the node is not currently managed, this is essentially a no-op.\n       * @param {Node} node\n       * @param {InertRoot} inertRoot\n       * @return {InertNode?} The potentially destroyed InertNode associated with this node, if any.\n       */\n\n    }, {\n      key: 'deregister',\n      value: function deregister(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n        if (!inertNode) {\n          return null;\n        }\n\n        inertNode.removeInertRoot(inertRoot);\n        if (inertNode.destroyed) {\n          this._managedNodes.delete(node);\n        }\n\n        return inertNode;\n      }\n\n      /**\n       * Callback used when document has finished loading.\n       */\n\n    }, {\n      key: '_onDocumentLoaded',\n      value: function _onDocumentLoaded() {\n        // Find all inert roots in document and make them actually inert.\n        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = inertElements[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var inertElement = _step7.value;\n\n            this.setInert(inertElement, true);\n          }\n\n          // Comment this out to use programmatic API only.\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n\n        this._observer.observe(this._document.body, { attributes: true, subtree: true, childList: true });\n      }\n\n      /**\n       * Callback used when mutation observer detects attribute changes.\n       * @param {MutationRecord} records\n       * @param {MutationObserver} self\n       */\n\n    }, {\n      key: '_watchForInert',\n      value: function _watchForInert(records, self) {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = records[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var record = _step8.value;\n\n            switch (record.type) {\n              case 'childList':\n                var _iteratorNormalCompletion9 = true;\n                var _didIteratorError9 = false;\n                var _iteratorError9 = undefined;\n\n                try {\n                  for (var _iterator9 = slice.call(record.addedNodes)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                    var node = _step9.value;\n\n                    if (node.nodeType !== Node.ELEMENT_NODE) {\n                      continue;\n                    }\n                    var inertElements = slice.call(node.querySelectorAll('[inert]'));\n                    if (index(node, '[inert]')) {\n                      inertElements.unshift(node);\n                    }\n                    var _iteratorNormalCompletion10 = true;\n                    var _didIteratorError10 = false;\n                    var _iteratorError10 = undefined;\n\n                    try {\n                      for (var _iterator10 = inertElements[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                        var inertElement = _step10.value;\n\n                        this.setInert(inertElement, true);\n                      }\n                    } catch (err) {\n                      _didIteratorError10 = true;\n                      _iteratorError10 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion10 && _iterator10.return) {\n                          _iterator10.return();\n                        }\n                      } finally {\n                        if (_didIteratorError10) {\n                          throw _iteratorError10;\n                        }\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError9 = true;\n                  _iteratorError9 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                      _iterator9.return();\n                    }\n                  } finally {\n                    if (_didIteratorError9) {\n                      throw _iteratorError9;\n                    }\n                  }\n                }\n\n                break;\n              case 'attributes':\n                if (record.attributeName !== 'inert') {\n                  continue;\n                }\n                var target = record.target;\n                var inert = target.hasAttribute('inert');\n                this.setInert(target, inert);\n                break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n      }\n    }]);\n    return InertManager;\n  }();\n\n  /**\n   * Recursively walk the composed tree from |node|.\n   * @param {Node} node\n   * @param {(function (Element))=} callback Callback to be called for each element traversed,\n   *     before descending into child nodes.\n   * @param {ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\n   */\n\n\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      var element = /** @type {Element} */node;\n      if (callback) {\n        callback(element);\n      }\n\n      // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n      var shadowRoot = element.shadowRoot || element.webkitShadowRoot;\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      }\n\n      // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'content') {\n        var content = /** @type {HTMLContentElement} */element;\n        // Verifies if ShadowDom v0 is supported.\n        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n        for (var i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n\n      // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n      if (element.localName == 'slot') {\n        var slot = /** @type {HTMLSlotElement} */element;\n        // Verify if ShadowDom v1 is supported.\n        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];\n        for (var _i = 0; _i < _distributedNodes.length; _i++) {\n          composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n        }\n        return;\n      }\n    }\n\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n    var child = node.firstChild;\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * Adds a style element to the node containing the inert specific styles\n   * @param {Node} node\n   */\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style')) {\n      return;\n    }\n    var style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  user-select: none;\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '}\\n';\n    node.appendChild(style);\n  }\n\n  /**\n   * `Node#contains()` polyfill.\n   *\n   * See: http://compatibility.shwups-cms.ch/en/polyfills/?&id=1\n   *\n   * @param {Node} node\n   * @param {Node} other\n   * @return {Boolean}\n   * @public\n   */\n  function contains(node, other) {\n    return other && (node === other || !!(node.compareDocumentPosition(other) & 16));\n  }\n\n  var inertManager = new InertManager(document);\n\n  Object.defineProperty(Element.prototype, 'inert', {\n    enumerable: true,\n    get: function get$$1() {\n      return this.hasAttribute('inert');\n    },\n    set: function set$$1(inert) {\n      inertManager.setInert(this, inert);\n    }\n  });\n})(document);\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuanM/ZTc4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIERPTSBlbGVtZW50IG1hdGNoZXMgYSBDU1Mgc2VsZWN0b3JcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2hlcyhlbGVtLCBzZWxlY3Rvcikge1xuICAvLyBWZW5kb3Itc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zIG9mIGBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKClgLlxuICB2YXIgcHJvdG8gPSB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVNYXRjaGVzID0gcHJvdG8ubWF0Y2hlcyB8fFxuICAgICAgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICBwcm90by5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgcHJvdG8ub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG4gIGlmICghZWxlbSB8fCBlbGVtLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHBhcmVudEVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG5cbiAgLy8gdXNlIG5hdGl2ZSAnbWF0Y2hlcydcbiAgaWYgKG5hdGl2ZU1hdGNoZXMpIHtcbiAgICByZXR1cm4gbmF0aXZlTWF0Y2hlcy5jYWxsKGVsZW0sIHNlbGVjdG9yKTtcbiAgfVxuXG4gIC8vIG5hdGl2ZSBzdXBwb3J0IGZvciBgbWF0Y2hlc2AgaXMgbWlzc2luZyBhbmQgYSBmYWxsYmFjayBpcyByZXF1aXJlZFxuICB2YXIgbm9kZXMgPSBwYXJlbnRFbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICB2YXIgbGVuID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0gPT09IGVsZW0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYG1hdGNoZXNgXG4gKi9cblxudmFyIGluZGV4ID0gbWF0Y2hlcztcblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgdGhlIFczQyBTb2Z0d2FyZSBhbmQgRG9jdW1lbnQgTGljZW5zZVxuICogKGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvMjAxNS9jb3B5cmlnaHQtc29mdHdhcmUtYW5kLWRvY3VtZW50KS5cbiAqL1xuXG4oZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKTpBcnJheX0gKi9cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXSddLmpvaW4oJywnKTtcblxuICAvKipcbiAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAqIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICpcbiAgICogLSB0byBjcmVhdGUgYW5kIG1haW50YWluIGEgc2V0IG9mIG1hbmFnZWQgYEluZXJ0Tm9kZWBzLCBpbmNsdWRpbmcgd2hlbiBtdXRhdGlvbnMgb2NjdXIgaW4gdGhlXG4gICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgKiAgIGVhY2ggZm9jdXNhYmxlIG5vZGUgaW4gdGhlIHN1YnRyZWUgd2l0aCB0aGUgc2luZ2xldG9uIGBJbmVydE1hbmFnZXJgIHdoaWNoIG1hbmFnZXMgYWxsIGtub3duXG4gICAqICAgZm9jdXNhYmxlIG5vZGVzIHdpdGhpbiBpbmVydCBzdWJ0cmVlcy4gYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgXG4gICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICpcbiAgICogLSB0byBub3RpZnkgYWxsIG1hbmFnZWQgYEluZXJ0Tm9kZWBzIHdoZW4gdGhpcyBzdWJ0cmVlIHN0b3BzIGJlaW5nIGluZXJ0IChpLmUuIHdoZW4gdGhlIGBpbmVydGBcbiAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgKiAgIGBkZXJlZ2lzdGVyYCBtZXRob2Qgb24gYEluZXJ0TWFuYWdlcmAgZm9yIGVhY2ggbWFuYWdlZCBpbmVydCBub2RlLlxuICAgKi9cblxuICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEVsZW1lbnQgYXQgdGhlIHJvb3Qgb2YgdGhlIGluZXJ0IHN1YnRyZWUuXG4gICAgICogQHBhcmFtIHtJbmVydE1hbmFnZXJ9IGluZXJ0TWFuYWdlciBUaGUgZ2xvYmFsIHNpbmdsZXRvbiBJbmVydE1hbmFnZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0Um9vdChyb290RWxlbWVudCwgaW5lcnRNYW5hZ2VyKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAvKiogQHR5cGUge0luZXJ0TWFuYWdlcn0gKi9cbiAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IGluZXJ0TWFuYWdlcjtcblxuICAgICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7U2V0PE5vZGU+fVxuICAgICAgICogQWxsIG1hbmFnZWQgZm9jdXNhYmxlIG5vZGVzIGluIHRoaXMgSW5lcnRSb290J3Mgc3VidHJlZS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldChbXSk7XG5cbiAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gdGhpcy5fcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgIC8vIE1ha2UgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgc3VidHJlZSB1bmZvY3VzYWJsZSBhbmQgYWRkIHRoZW0gdG8gX21hbmFnZWROb2Rlc1xuICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhdGNoIGZvcjpcbiAgICAgIC8vIC0gYW55IGFkZGl0aW9ucyBpbiB0aGUgc3VidHJlZTogbWFrZSB0aGVtIHVuZm9jdXNhYmxlIHRvb1xuICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAvLyAtIGF0dHJpYnV0ZSBjaGFuZ2VzOiBpZiBgdGFiaW5kZXhgIGlzIGFkZGVkLCBvciByZW1vdmVkIGZyb20gYW4gaW50cmluc2ljYWxseSBmb2N1c2FibGVcbiAgICAgIC8vICAgZWxlbWVudCwgbWFrZSB0aGF0IG5vZGUgYSBtYW5hZ2VkIG5vZGUuXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX3Jvb3RFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiAgVGhpcyB1bndpbmRzIGFsbCBvZiB0aGUgc3RhdGVcbiAgICAgKiBzdG9yZWQgaW4gdGhpcyBvYmplY3QgYW5kIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIGFsbCBvZiB0aGUgbWFuYWdlZCBub2Rlcy5cbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzU2F2ZWRBcmlhSGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdGhpcy5zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gbnVsbDtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLl9tYW5hZ2VkTm9kZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgaW5lcnROb2RlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcmV0dXJuIHtTZXQ8SW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShzdGFydE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGU7XG4gICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcm9vdCA9IG5vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWlucyhzdGFydE5vZGUsIGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgZGVzY2VuZGFudCBpbmVydCByb290IGJlY29tZXMgdW4taW5lcnQsIGl0cyBkZXNjZW5kYW50cyB3aWxsIHN0aWxsIGJlIGluZXJ0IGJlY2F1c2Ugb2ZcbiAgICAgICAgLy8gdGhpcyBpbmVydCByb290LCBzbyBhbGwgb2YgaXRzIG1hbmFnZWQgbm9kZXMgbmVlZCB0byBiZSBhZG9wdGVkIGJ5IHRoaXMgSW5lcnRSb290LlxuICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgbm9kZS5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleChub2RlLCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tYW5hZ2VOb2RlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5hZGQoaW5lcnROb2RlKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZU5vZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgIGlmIChpbmVydE5vZGUpIHtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZGVsZXRlKGluZXJ0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2Fkb3B0SW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRvcHRJbmVydFJvb3Qobm9kZSkge1xuICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAvLyBEdXJpbmcgaW5pdGlhbGlzYXRpb24gdGhpcyBpbmVydCByb290IG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgeWV0LFxuICAgICAgICAvLyBzbyByZWdpc3RlciBpdCBub3cgaWYgbmVlZCBiZS5cbiAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIuc2V0SW5lcnQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbmVydFN1YnJvb3QubWFuYWdlZE5vZGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgc2F2ZWRJbmVydE5vZGUgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICogQHBhcmFtIHtNdXRhdGlvblJlY29yZH0gcmVjb3Jkc1xuICAgICAgICogQHBhcmFtIHtNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSByZWNvcmRzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBlcnI7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfbm9kZSA9IF9zdGVwNS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VTdWJ0cmVlKF9ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNSA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I1ID0gZXJyO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ICYmIF9pdGVyYXRvcjUucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjUucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I1O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjYgPSB0aGlzLl9tYW5hZ2VkTm9kZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hbmFnZWROb2RlID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyh0YXJnZXQsIG1hbmFnZWROb2RlLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I2ID0gZXJyO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ICYmIF9pdGVyYXRvcjYucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuICdfc2F2ZWRBcmlhSGlkZGVuJyBpbiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvKiogQHBhcmFtIHtzdHJpbmd9IGFyaWFIaWRkZW4gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NhdmVkQXJpYUhpZGRlbicsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShhcmlhSGlkZGVuKSB7XG4gICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXG4gICAgICAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIEluZXJ0Um9vdDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBgSW5lcnROb2RlYCBpbml0aWFsaXNlcyBhbmQgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBub2RlLlxuICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAqXG4gICAqIE9uIGNvbnN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgc2F2ZXMgdGhlIGV4aXN0aW5nIGB0YWJpbmRleGAgdmFsdWUgZm9yIHRoZSBub2RlLCBpZiBhbnksIGFuZFxuICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgKiBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZSBvciBub3QuXG4gICAqXG4gICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICogYEluZXJ0Um9vdGAgaXMgZGVzdHJveWVkLCBhbmQgY2FsbHMgYEluZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKClgLCB0aGUgYEluZXJ0TWFuYWdlcmAgbm90aWZpZXMgdGhlXG4gICAqIGBJbmVydE5vZGVgIHZpYSBgcmVtb3ZlSW5lcnRSb290KClgLCB3aGljaCBpbiB0dXJuIGRlc3Ryb3lzIHRoZSBgSW5lcnROb2RlYCBpZiBubyBgSW5lcnRSb290YHNcbiAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgKiBvciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBpZiB0aGUgZWxlbWVudCBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZS5cbiAgICovXG5cblxuICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICogQHBhcmFtIHtJbmVydFJvb3R9IGluZXJ0Um9vdCBUaGUgaW5lcnQgcm9vdCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZXJ0IG5vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgLyoqIEB0eXBlIHtOb2RlfSAqL1xuICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7U2V0PEluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAqICAgIElmIGFuZCBvbmx5IGlmIHRoaXMgc2V0IGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAqL1xuXG5cbiAgICBjcmVhdGVDbGFzcyhJbmVydE5vZGUsIFt7XG4gICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX25vZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNTYXZlZFRhYkluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLnNhdmVkVGFiSW5kZXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgIGlmICh0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbm9kZS5mb2N1cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAvKipcbiAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICBpZiAoaW5kZXgobm9kZSwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgIGlmIChub2RlLnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBub2RlLnRhYkluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIG5vZGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBub2RlLnRhYkluZGV4O1xuICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIGFub3RoZXIgaW5lcnQgcm9vdCB0byB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgKiBAcGFyYW0ge0luZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICogQHBhcmFtIHtJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdyZW1vdmVJbmVydFJvb3QnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmRlbGV0ZShpbmVydFJvb3QpO1xuICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXN0cm95ZWQnLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95ZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuICdfc2F2ZWRUYWJJbmRleCcgaW4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLyoqIEByZXR1cm4ge05vZGV9ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdub2RlJyxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgICAgfVxuXG4gICAgICAvKiogQHBhcmFtIHtudW1iZXJ9IHRhYkluZGV4ICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdzYXZlZFRhYkluZGV4JyxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgfVxuXG4gICAgICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICAgICAgLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBJbmVydE5vZGU7XG4gIH0oKTtcblxuICAvKipcbiAgICogSW5lcnRNYW5hZ2VyIGlzIGEgcGVyLWRvY3VtZW50IHNpbmdsZXRvbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBhbGwgaW5lcnQgcm9vdHMgYW5kIG5vZGVzLlxuICAgKlxuICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAqIHByb3BlcnR5IHNldCB0byBgdHJ1ZWAsIHRoZSBgc2V0SW5lcnRgIG1ldGhvZCBjcmVhdGVzIGFuIGBJbmVydFJvb3RgIG9iamVjdCBmb3IgdGhlIGVsZW1lbnQuXG4gICAqIFRoZSBgSW5lcnRSb290YCBpbiB0dXJuIHJlZ2lzdGVycyBpdHNlbGYgYXMgbWFuYWdpbmcgYWxsIG9mIHRoZSBlbGVtZW50J3MgZm9jdXNhYmxlIGRlc2NlbmRhbnRcbiAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAqIGlzIGNyZWF0ZWQgZm9yIGVhY2ggc3VjaCBub2RlLCB2aWEgdGhlIGBfbWFuYWdlZE5vZGVzYCBtYXAuXG4gICAqL1xuXG5cbiAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2N1bWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ7IEluZXJ0TWFuYWdlciBuZWVkcyB0byB3cmFwIGEgZG9jdW1lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG4gICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuXG4gICAgICAvKipcbiAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgKiBAdHlwZSB7TWFwPE5vZGUsIEluZXJ0Tm9kZT59XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbGwgaW5lcnQgcm9vdHMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAqIEB0eXBlIHtNYXA8Tm9kZSwgSW5lcnRSb290Pn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBNYXAoKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBPYnNlcnZlciBmb3IgbXV0YXRpb25zIG9uIGBkb2N1bWVudC5ib2R5YC5cbiAgICAgICAqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5lcnRcbiAgICAgKi9cblxuXG4gICAgY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgIGlmICghY29udGFpbnModGhpcy5fZG9jdW1lbnQuYm9keSwgcm9vdCkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgbm9uLWluZXJ0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9pbmVydFJvb3QgPSB0aGlzLl9pbmVydFJvb3RzLmdldChyb290KTtcbiAgICAgICAgICBfaW5lcnRSb290LmRlc3RydWN0b3IoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmRlbGV0ZShyb290KTtcbiAgICAgICAgICByb290LnJlbW92ZUF0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEdldCB0aGUgSW5lcnRSb290IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmVydCByb290IGVsZW1lbnQsIGlmIGFueS5cbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICogQHJldHVybiB7SW5lcnRSb290P31cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0SW5lcnRSb290JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5lcnRSb290cy5nZXQoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBub2RlIGhhcyBhIHByZXZpb3VzbHkgZXhpc3RpbmcgaW5lcnQgcm9vdCwgdGhpcyBpbmVydCByb290IHdpbGxcbiAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgICAqIEBwYXJhbSB7SW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAqIEByZXR1cm4ge0luZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIG5vZGUgd2FzIGFscmVhZHkgaW4gYW4gaW5lcnQgc3VidHJlZVxuICAgICAgICAgIGluZXJ0Tm9kZS5hZGRJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICAvLyBVcGRhdGUgc2F2ZWQgdGFiaW5kZXggdmFsdWUgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgaW5lcnROb2RlLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmVydE5vZGUgPSBuZXcgSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZS1yZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBpbmVydCBub2RlLlxuICAgICAgICogUmVtb3ZlcyB0aGUgaW5lcnQgcm9vdCBmcm9tIHRoZSBJbmVydE5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMsIGFuZCByZW1vdmUgdGhlIGluZXJ0XG4gICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAqIElmIHRoZSBub2RlIGlzIG5vdCBjdXJyZW50bHkgbWFuYWdlZCwgdGhpcyBpcyBlc3NlbnRpYWxseSBhIG5vLW9wLlxuICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICAgKiBAcGFyYW0ge0luZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgKiBAcmV0dXJuIHtJbmVydE5vZGU/fSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5kZWxldGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I3ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IGluZXJ0RWxlbWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDc7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSAoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBpbmVydEVsZW1lbnQgPSBfc3RlcDcudmFsdWU7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb21tZW50IHRoaXMgb3V0IHRvIHVzZSBwcm9ncmFtbWF0aWMgQVBJIG9ubHkuXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNyA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I3ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ICYmIF9pdGVyYXRvcjcucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjcucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiBAcGFyYW0ge011dGF0aW9uUmVjb3JkfSByZWNvcmRzXG4gICAgICAgKiBAcGFyYW0ge011dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YXRjaEZvckluZXJ0KHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yOCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I4ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yOCA9IHJlY29yZHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDg7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjggPSAoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOCA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSBfc3RlcDgudmFsdWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjkgPSBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uOSA9IChfc3RlcDkgPSBfaXRlcmF0b3I5Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb245ID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF9zdGVwOS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXgobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMudW5zaGlmdChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMTAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMTAgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IxMCA9IGluZXJ0RWxlbWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDEwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xMCA9IChfc3RlcDEwID0gX2l0ZXJhdG9yMTAubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudCA9IF9zdGVwMTAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMTAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMTAgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEwICYmIF9pdGVyYXRvcjEwLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IxMC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yOSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjkgPSBlcnI7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjkgJiYgX2l0ZXJhdG9yOS5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I5LnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSAhPT0gJ2luZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSByZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yOCA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I4ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb244ICYmIF9pdGVyYXRvcjgucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjgucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoRWxlbWVudCkpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnQgdHJhdmVyc2VkLFxuICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICogQHBhcmFtIHtTaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovbm9kZTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAvLyBJZiBpdCBoYXMgYSBTaGFkb3dSb290LCBpZ25vcmUgYWxsIGNoaWxkIGVsZW1lbnRzIC0gdGhlc2Ugd2lsbCBiZSBwaWNrZWRcbiAgICAgIC8vIHVwIGJ5IHRoZSA8Y29udGVudD4gb3IgPHNoYWRvdz4gZWxlbWVudHMuIERlc2NlbmQgc3RyYWlnaHQgaW50byB0aGVcbiAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICB2YXIgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdCB8fCBlbGVtZW50LndlYmtpdFNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHNoYWRvd1Jvb3QsIGNhbGxiYWNrLCBzaGFkb3dSb290KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBhIDxjb250ZW50PiBlbGVtZW50LCBkZXNjZW5kIGludG8gZGlzdHJpYnV0ZWQgZWxlbWVudHMgLSB0aGVzZVxuICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gLyoqIEB0eXBlIHtIVE1MQ29udGVudEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgLy8gVmVyaWZpZXMgaWYgU2hhZG93RG9tIHYwIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGRpc3RyaWJ1dGVkTm9kZXNbaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICB2YXIgc2xvdCA9IC8qKiBAdHlwZSB7SFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBhZGRJbmVydFN0eWxlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsICdpbmVydC1zdHlsZScpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gJ1xcbicgKyAnW2luZXJ0XSB7XFxuJyArICcgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbicgKyAnICBjdXJzb3I6IGRlZmF1bHQ7XFxuJyArICd9XFxuJyArICdcXG4nICsgJ1tpbmVydF0sIFtpbmVydF0gKiB7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICd9XFxuJztcbiAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgTm9kZSNjb250YWlucygpYCBwb2x5ZmlsbC5cbiAgICpcbiAgICogU2VlOiBodHRwOi8vY29tcGF0aWJpbGl0eS5zaHd1cHMtY21zLmNoL2VuL3BvbHlmaWxscy8/JmlkPTFcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7Tm9kZX0gb3RoZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gY29udGFpbnMobm9kZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgJiYgKG5vZGUgPT09IG90aGVyIHx8ICEhKG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXIpICYgMTYpKTtcbiAgfVxuXG4gIHZhciBpbmVydE1hbmFnZXIgPSBuZXcgSW5lcnRNYW5hZ2VyKGRvY3VtZW50KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWxlbWVudC5wcm90b3R5cGUsICdpbmVydCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoaW5lcnQpIHtcbiAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgfVxuICB9KTtcbn0pKGRvY3VtZW50KTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/*!*****************************************!*\
  !*** ./node_modules/focusable/index.js ***!
  \*****************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex=\"0\"], [contenteditable], audio[controls], video[controls]'\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mb2N1c2FibGUvaW5kZXguanM/MmM2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9ICdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCBbdGFiaW5kZXg9XCIwXCJdLCBbY29udGVudGVkaXRhYmxlXSwgYXVkaW9bY29udHJvbHNdLCB2aWRlb1tjb250cm9sc10nXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mb2N1c2FibGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ })
/******/ ]);